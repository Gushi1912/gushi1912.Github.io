<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gushi1912.github.io</id>
    <title>顾咕咕的博客</title>
    <updated>2021-09-29T09:34:34.056Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gushi1912.github.io"/>
    <link rel="self" href="https://gushi1912.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://gushi1912.github.io/images/avatar.png</logo>
    <icon>https://gushi1912.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 顾咕咕的博客</rights>
    <entry>
        <title type="html"><![CDATA[Docker-基础篇（二）]]></title>
        <id>https://gushi1912.github.io/post/docker-ji-chu-pian-er/</id>
        <link href="https://gushi1912.github.io/post/docker-ji-chu-pian-er/">
        </link>
        <updated>2021-09-29T08:36:28.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gushi1912.github.io/post-images/1632904816234.png" alt="" loading="lazy"></figure>
<h1 id="容器数据卷">容器数据卷</h1>
<h2 id="什么是容器数据卷">什么是容器数据卷</h2>
<p>Docker可以将应用和环境打包成一个镜像。<br>
对于容器中的数据，如果数据都存在容器中，那么删除容器之后，数据就会丢失。所以我们需要：<strong>数据持久化</strong>。<br>
Docker里的容器之间有一个数据共享的技术，Docker容器中产生的数据可以同步到本地。<br>
这就是容器卷技术，实际就是<strong>将宿主机的目录挂载到容器上</strong>。</p>
<p>卷是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能绕过联合文件系统提供一些用于持续存储或共享数据的特性；<br>
卷的设计目的就是数据持久化，完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷。<br>
特点：</p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中更改的可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<h2 id="使用容器卷">使用容器卷</h2>
<blockquote>
<p>方式一：直接使用命令来挂载 -v（另一种方式见dokcerfile挂载）</p>
</blockquote>
<pre><code class="language-shell">docker run -it -v 主机目录:容器内的目录 镜像名/ID

#启动一个centos容器
docker run -it -v /home/gugugu:/home --name centos centos /bin/bash
#使用inspect命令来查看挂载情况
docker inspect centos
</code></pre>
<p><img src="https://gushi1912.github.io/post-images/1632904867185.png" alt="" loading="lazy"><br>
在容器中的挂载目录中创建一个文件之后，我们可以在宿主机相对应的目录下看到对应文件。<br>
当我们停止容器之后，在宿主机的对应目录下修改该文件，启动容器之后我们可以看到修改的文件会自动同步过来，这就是双向绑定。<br>
这样做的好处：比如我们启动一个nginx容器，需要修改nginx中的配置文件，我们可以不用每次进入容器中修改，可以使用挂载的方式将nginx的配置文件同步到宿主机中，这样就可以直接在宿主机中修改，而不用进入容器中。</p>
<h2 id="实战安装mysql">实战：安装MYSQL</h2>
<pre><code class="language-shell">#首先下载镜像
docker pull mysql:5.7
</code></pre>
<p>具体怎么运行mysql可以参考Dockerhub中的说明：<a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a><br>
想要在外部修改mysql配置文件来启动mysql，首先需要先启动mysql将其中的配置文件拷贝一份到宿主机上要挂载的目录</p>
<pre><code class="language-shell">#先启动mysql
docker run --name mysql -d -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
-e 配置环境变量 MYSQL_ROOT_PASSWORD是启动mysql必须的参数（强制性的）
#使用docker cp命令将容器中的文件拷贝到宿主机目录
docker cp mysql:/etc/mysql/conf.d/. /home/mysql/conf
#拷贝完成之后停止容器，删除，然后使用容器卷技术挂载再启动
docker run --name mysql -p 3306:3306 -d -v /home/mysql/data:/var/lib/mysql -v /home/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
</code></pre>
<p>启动成功之后就可以测试是否挂载成功。<br>
我们首先使用navicat远程连接测试是否可以连接，正常情况下是可以连接的。<br>
连接成功之后我们在mysql中新建一个数据库test_db。<br>
<img src="https://gushi1912.github.io/post-images/1632904898511.png" alt="" loading="lazy"><br>
然后打开容器中mysql存放数据的目录 <code>/var/lib/mysql/</code> 可以看到test_db目录：<br>
<img src="https://gushi1912.github.io/post-images/1632904915352.png" alt="" loading="lazy"><br>
打开宿柱机的挂载目录也可以看到相应的文件。<br>
<img src="https://gushi1912.github.io/post-images/1632904925672.png" alt="" loading="lazy"><br>
接下来测试配置文件目录的挂载情况，我们在宿主机的配置文件目录/home/mysql/conf下创建一个新的文件test.html。<br>
<img src="https://gushi1912.github.io/post-images/1632904941253.png" alt="" loading="lazy"><br>
打开容器中MySQL的的配置文件路径，可以看到新增文件test.html，说明所有路径都成功挂载。<br>
我们停止并删除容器之后可以看到宿主机中的目录以及文件均未被删除。<br>
<img src="https://gushi1912.github.io/post-images/1632904951900.png" alt="" loading="lazy"></p>
<h2 id="具名挂载和匿名挂载">具名挂载和匿名挂载</h2>
<p>具名挂载就是指定挂载卷的名称   <code>-v 具名路径目录名称：容器路径</code> <br>
匿名挂载就是不指定挂载卷的名称 <code>-v 容器路径</code> <br>
指定路径挂载就是常用的指定宿主机挂载路径 <code>-v 宿主机路径:容器路径</code></p>
<pre><code class="language-shell">#匿名挂载测试
-P	表示随机映射端口
docker run --name nginx01 -P -v /etc/nginx nginx
#使用docker inspect nginx01 查看具体的挂载路径
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gushi1912.github.io/post-images/1632904973601.png" alt="" loading="lazy"></figure>
<pre><code class="language-shell">#具名挂载测试
docker run --name nginx02 -P -v nginx-conf:/etc/nginx nginx
docker inspect nginx02
</code></pre>
<p><img src="https://gushi1912.github.io/post-images/1632905003141.png" alt="" loading="lazy"><br>
<strong>关于Docker volume的操作</strong></p>
<pre><code class="language-shell">docker volume 
ls							#列出所有的挂载卷
inspect 卷名 		#查看卷信息
create      Create a volume
inspect     Display detailed information on one or more volumes
ls          List volumes
prune       Remove all unused local volumes
rm          Remove one or more volumes

</code></pre>
<p><img src="https://gushi1912.github.io/post-images/1632905039413.png" alt="" loading="lazy"><br>
<strong>补充内容</strong></p>
<pre><code class="language-shell">docker run --name nginx03 -P -v nginx-conf:/etc/nginx:ro nginx
ro	readonly-只读
rw	readwrite-可读可写
</code></pre>
<p>容器中的路径后面的ro/rw表示操作权限，<strong>如果是ro，就表示该路径在容器中只允许读操作，只能从宿主机的挂载路径中进行读写操作。</strong><br>
**</p>
<h2 id="初识dockerfile">初识DockerFile</h2>
<p>DockerFile就是构建Docker镜像的一个命令行文件。通过这个脚本可以生成一个镜像，镜像是一层一层的，对应脚本中的一个一个命令，每一个命令就相当于一层。</p>
<blockquote>
<p>挂载的另一种方式就是使用dockerfile，常用文件名为Dockerfile。</p>
</blockquote>
<pre><code class="language-shell">#dockfile内容
FROM centos

VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]        #此处的挂载是匿名挂载

CMD echo &quot;------end------&quot;
CMD /bin/bash
#命令都是采用大写


[root@iZuf6e1jhv5i6fv2ux4x53Z dockerfile]# docker build -f dockerfile1 -t gugugu/centos .
Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---&gt; 300e315adb2f
Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]
 ---&gt; Running in b1d5b8d29259
Removing intermediate container b1d5b8d29259
 ---&gt; 373a82c56065
Step 3/4 : CMD echo &quot;------end------&quot;
 ---&gt; Running in 513ccf83a7d5
Removing intermediate container 513ccf83a7d5
 ---&gt; 5dc1f5741b8c
Step 4/4 : CMD /bin/bash
 ---&gt; Running in 7d4f53bc1763
Removing intermediate container 7d4f53bc1763
 ---&gt; 9df6c7178d77
Successfully built 9df6c7178d77
Successfully tagged gugugu/centos:latest
[root@iZuf6e1jhv5i6fv2ux4x53Z dockerfile]# docker images
REPOSITORY      TAG       IMAGE ID       CREATED         SIZE
gugugu/centos   latest    9df6c7178d77   4 seconds ago   209MB
tomcat01        GU        58ed273bfacf   30 hours ago    654MB
hello-world     latest    d1165f221234   9 days ago      13.3kB
mysql           5.7       a70d36bc331a   7 weeks ago     449MB
</code></pre>
<p>构建镜像成功之后我们启动容器，并进入容器内部</p>
<pre><code class="language-shell">docker run -it gugugu/centos /bin/bash
</code></pre>
<p>可以看到容器内部有两个挂载的目录<br>
<img src="https://gushi1912.github.io/post-images/1632905052203.png" alt="" loading="lazy"><br>
使用容器查看命令查看容器的具体细节可以看到宿主机中的对应的挂载目录 <code>docker inspect 52987210ea73</code> ,并且使用的是匿名挂载的方式。<br>
<img src="https://gushi1912.github.io/post-images/1632905058659.png" alt="" loading="lazy"><br>
这种挂载方式我们平时使用的比较多，主要用于构建我们自己的镜像。<br>
若构建镜像的时候没有使用dockerfile来挂载卷，我们还可以使用-v的方式在启动的时候挂载。</p>
<h2 id="数据容器卷">数据容器卷</h2>
<p>数据卷容器可以理解为某个容器作为父容器，其他容器挂载到该容器上,这个被挂载的容器成为数据卷容器，实现不同容器之间的数据同步，它们之间其实是双向绑定的。实际上还是利用挂载的原理，宿主机的目录同时挂载到三个容器上，具体可以使用docker inspect命令查看。</p>
<p>命令： <code>--volumes-from</code> <br>
我们先启动三个容器，一个容器作为父容器，另外两个容器挂载到父容器上实现数据同步。</p>
<pre><code class="language-shell">#使用我们上面使用dockerfile生成的镜像来测试
docker run -it --name centos01 gugugu/centos
docker run -it --name centos02 --volumes-from centos01 gugugu/centos
docker run -it --name centos03 --volumes-from centos01 gugugu/centos
</code></pre>
<p>我们可以在三个容器的其中一个的挂载卷目录上添加删除文件，在另外两个容器中查看挂在卷中的文件同步情况。<br>
为了证明实际是宿主机的挂载卷目录同时挂载到三个容器上，我们可以使用 <code>docker inspect</code> 查看任一容器的宿主机挂载目录的位置，在宿主机目录上进行添加和删除操作，然后在三个容器的挂载目录查看文件同步情况和宿主机目录一致。<br>
具体操作就不截图展示了。</p>
<hr>
<h1 id="dockerfile">DockerFile</h1>
<p>DockerFIle是用来构建docker镜像的文件。<br>
构建步骤：</p>
<ol>
<li>编写一个DockerFile文件</li>
<li>使用docker build命令构建docker镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像（DockerHub、阿里云镜像仓库）</li>
</ol>
<p><img src="https://gushi1912.github.io/post-images/1632905072987.png" alt="" loading="lazy"><br>
上图是centos官方镜像的DockerFile，可以发现很多功能都没有，只是一个简单的基础版镜像。<br>
我们可以自己制作镜像，添加自己想要的功能。</p>
<h2 id="dockerfile构建过程">DockerFile构建过程</h2>
<p><strong>基础知识</strong></p>
<ol>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行是按从上到下的顺序</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交。</li>
</ol>
<p><strong>构建过程</strong></p>
<ul>
<li>Dokcer从基础镜像运行一个容器。</li>
<li>执行一条指令，对容器做出修改。</li>
<li>执行类似docker commit的操作，提交一个新的镜像层。</li>
<li>Docker再基于刚刚提交的镜像运行一个新的容器。</li>
<li>执行DockerFile的下一条指令，直到所有的指令都执行完毕。</li>
</ul>
<blockquote>
<p>每一个DockerFile的第一行指令都应该是FROM，FROM指令指定一个已经存在的镜像，后续的操作都是基于该镜像进行，这个镜像被称为基础镜像（base image）。</p>
</blockquote>
<h2 id="dockerfile命令">DockerFile命令</h2>
<figure data-type="image" tabindex="3"><img src="https://gushi1912.github.io/post-images/1632905086137.png" alt="" loading="lazy"></figure>
<blockquote>
<p>创建一个属于自己的镜像</p>
</blockquote>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z dockerfile]# vim mydockerfile
[root@iZuf6e1jhv5i6fv2ux4x53Z dockerfile]# vim mydockerfile

FROM centos
MAINTAINER gugugu&lt;gushi1912@gmail.com&gt;

ENV MYPATH /usr/local
WORKDIR $MYPATH

RUN yum install -y vim &amp;&amp; yum install -y net-tools

EXPOSE 80

CMD echo $MYPATH
CMD echo &quot;------end------&quot;
CMD /bin/bash

#以上三个CMD命令实际上只会执行最后一个
#CMD[]将命令用数组包装起来是Docker推荐使用的方式，它会告诉Docker按照原命令来执行，若不用[]括起来，Docker执行指令的时候就会在命令前加上
/bin/sh -c 这可能会起到意想不到的作用。同样适用于ENTRYPOINT.
</code></pre>
<p>然后使用docker build 命令来构建镜像</p>
<pre><code class="language-shell">docker build -f mydockerfile -t mycentos:0.1 .
# . 表示在同级目录中查找Dockerfile文件，也可以指定一个git仓库的源地址来指定Dockerfile的位置
#执行成功之后
Successfully built 05871b41d7ca
Successfully tagged mycentos:0.1
</code></pre>
<p>运行我们所创建的镜像</p>
<pre><code class="language-shell">docker run -it mycentos:0.1
</code></pre>
<p>运行之后会自动进入我们在dockerfile中定义的工作路径，并且vim指令和ifconfig指令都可以使用。<br>
<img src="https://gushi1912.github.io/post-images/1632905101915.png" alt="" loading="lazy"><br>
查看镜像的构建历史指令： <code>docker history 镜像</code></p>
<h2 id="cmd和entrypoint的区别">CMD和ENTRYPOINT的区别</h2>
<p><code>CMD</code> :指定运行的命令，这个命令是在docker run的过程中执行，效果是容器启动之后自动启动一个执行此命令的进程。一个DockerFile中可以有多个CMD命令。但是实际执行的命令只有最后一条指令。我们也可以在docker run 指令后面添加命令，添加的命令会覆盖DockerFile中的指令。<br>
<code>ENTRYPOINT</code> : 镜像制作完成之后启动容器时作为默认执行的命令，这个命令不会被docker run命令后跟着的指令覆盖掉，而是会追加到ENTRYPOINT命令之后执行。如果一个DockerFile里有CMD和ENTRYPOINT命令同时存在，那么CMD命令将会被追加到ENTRYPOINT指令之后执行。</p>
<pre><code class="language-shell">#创建一个测试CMD命令的dockerfile
FROM centos
CMD [&quot;ls&quot;,&quot;-a&quot;]
</code></pre>
<p>构建镜像之后执行dokcer run 命令会直接执行 <code>ls -a</code> 命令，如果在docker run 命令之后加上 <code>-l</code>  则会报错。</p>
<pre><code class="language-shell">#创建一个测试ENTRYPOINT命令的dockerfile
FROM centos
CMD [&quot;mkdir&quot;,&quot;gugugu&quot;]         
ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]
</code></pre>
<p>实际执行docker run命令的时候CMD命令确实会追加到ENTRYPOINT命令之后，不过只是单纯的拼接成 <code>ls -a mkdir gugugu</code> ,并没有用 <code>&amp;</code> 连接,实际测试用&amp;命令连接也无法识别，不能正确执行，因此猜测在追加指令的情况下的命令仍是一条完整单一功能指令才能正确执行。<br>
把dockerfile中的CMD命令删掉，之后执行 <code>docker run image -l</code>  可以正常执行。</p>
<h2 id="实战构建tomcat镜像">实战：构建tomcat镜像</h2>
<ol>
<li>tomcat压缩包 jdk压缩包(jdk环境)</li>
<li>编写dockerfile文件，官方指定文件名DockerFile，不用-f指定文件名</li>
</ol>
<h2 id="发布自己的镜像">发布自己的镜像</h2>
<blockquote>
<p>发布到Dockerhub上</p>
</blockquote>
<ol>
<li>首先在<a href="https://hub.docker.com/">https://hub.docker.com/</a>上创建一个账号。</li>
<li>点击首页的Create a Repository创建一个私人仓库，用户仓库的命名为： <code>username/repositoryname</code> 。</li>
<li>在本地使用 <code>docker login -u username</code> 登录Dockerhub。</li>
<li>最后就可以使用docker push将自己的仓库发布到自己的私人仓库。</li>
</ol>
<pre><code class="language-shell">#docker push的使用方式
dokcer push docker-username/repository-name:tagname

在这里 repository-name标识一个项目（镜像）的名称，比如你要提交一个tomcat服务镜像，那么这个仓库名就应该为tomcat。
这个仓库中存储的就应该是tomcat这个服务的所有版本
即：
tomcat:01 
tomcat:02
...
</code></pre>
<blockquote>
<p>发布到阿里云镜像服务上</p>
</blockquote>
<ol>
<li>链接：<a href="https://cr.console.aliyun.com/cn-shanghai/instance/dashboard">https://cr.console.aliyun.com/cn-shanghai/instance/dashboard</a></li>
<li>首先创建命名空间</li>
<li>创建镜像仓库</li>
<li>按照说明来发布镜像</li>
</ol>
<p><strong>关于docker tag的使用</strong>：</p>
<pre><code class="language-shell">docker tag sourceImage[:tag] targetImage[:tag]
给镜像重命名，但是原有镜像还是存在的，新的镜像只是指向原有镜像
</code></pre>
<hr>
<h1 id="docker-网络">Docker 网络</h1>
<h2 id="理解docker0">理解Docker0</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620218102580-0819beb8-567d-405b-a1de-5aab0d37e406.png#align=left&amp;display=inline&amp;height=213&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=213&amp;originWidth=1011&amp;size=42243&amp;status=done&amp;style=none&amp;width=1011" alt="image.png" loading="lazy"><br>
<strong>问题</strong> ：Docker是如何处理容器网络访问的？？？</p>
<pre><code class="language-shell">#运行一个容器
[root@iZuf6e1jhv5i6fv2ux4x53Z gugugu]# docker run --name tomcat01 -P tomcat
#查看容器内部的网络地址 ip addr，我们可以发现容器启动的时候会得到一个eth0@if155的ip地址，这个是docker分配的！
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat01 ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
154: eth0@if155: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever

#在这里我们思考一个问题：宿主机能不能ping通容器内部？
答案是：能！！！
</code></pre>
<blockquote>
<p>原理</p>
</blockquote>
<ol>
<li>我们每启动一个docker容器，docker就会给docker容器分配一个ip。我们只要安装了docker，就会有一个网卡docker0（桥接模式）。使用的技术是 <strong>evth-pair技术。</strong></li>
</ol>
<p>ip addr之后，我们可以发现多了一个网卡155，这个和之前容器内部的网卡对应上了<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620219079493-0f867dd7-d1e6-4ee2-b10e-cdbd41bae3b6.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=243&amp;originWidth=959&amp;size=38265&amp;status=done&amp;style=none&amp;width=959" alt="image.png" loading="lazy"></p>
<ol start="2">
<li>再启动一个容器，然后 ip addr发现又增加了一个网卡，并且和容器一一对应</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620219246777-683f6c08-af10-4fee-bc83-1285a98f8f58.png#align=left&amp;display=inline&amp;height=174&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=174&amp;originWidth=792&amp;size=23072&amp;status=done&amp;style=none&amp;width=792" alt="image.png" loading="lazy"><br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620219291777-36fabf2a-104c-49ae-b6bf-eeb829fdd832.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=273&amp;originWidth=969&amp;size=44366&amp;status=done&amp;style=none&amp;width=969" alt="image.png" loading="lazy"><br>
我们发现这个容器增加的网卡都是一对对的，<br>
evth-apir就是一堆虚拟网络设备接口，他们都是成对出现的，一段连着协议，一段彼此相连，<br>
正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备，<br>
openstack，Docker容器之间的连接，OVS的连接使用的都是veth-pair技术。</p>
<ol start="3">
<li>测试tomcat01和tomcat02之间是否可以ping通？ <strong>可以</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620219638616-9f6233dc-9343-4abf-bbde-7eb46d854024.png#align=left&amp;display=inline&amp;height=145&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=145&amp;originWidth=673&amp;size=18875&amp;status=done&amp;style=none&amp;width=673" alt="image.png" loading="lazy"><br>
结论：tomcat01和tomcat02使用的都是同一个路由器：docker0<br>
所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们分配一个默认的可用的ip。<br>
Docker使用的是Linux的桥接模式，宿主机中的是一个Docker容器的网桥 docker0.<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620220170125-f731eabf-7e00-44e4-94d6-5fc0a5be3700.png#align=left&amp;display=inline&amp;height=446&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=891&amp;originWidth=1230&amp;size=130026&amp;status=done&amp;style=none&amp;width=615" alt="image.png" loading="lazy"><br>
Docker中的所有的网络接口都是虚拟的。虚拟的转发效率高！！！<br>
只要容器删除，对应的一堆网桥就消失了。<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620221267048-b7cab444-0086-40f0-a6ce-917c5ae599a6.png#align=left&amp;display=inline&amp;height=485&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=485&amp;originWidth=799&amp;size=38199&amp;status=done&amp;style=none&amp;width=799" alt="image.png" loading="lazy"></p>
<h2 id="-link">--link</h2>
<blockquote>
<p>思考一个场景，我们编写了一个微服务，database url=ip，如果项目不重启，数据库ip换掉了，我们希望可以处理这个问题，也就是希望可以通过名字来进行访问容器？</p>
</blockquote>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat02 ping tomcat01
ping: tomcat01: Name or service not known
#可以看到直接ping服务名是ping不通的

#使用--link之后可以通过服务名来ping通
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker run --name tomcat03 -d -P --link tomcat02 tomcat
8dc211d736835132996588a2506e89fd2b911fc10935284b760bd6b9877bc634
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                     NAMES
8dc211d73683   tomcat    &quot;catalina.sh run&quot;   3 seconds ago    Up 2 seconds    0.0.0.0:49162-&gt;8080/tcp   tomcat03
0dddcfb4c217   tomcat    &quot;catalina.sh run&quot;   26 minutes ago   Up 26 minutes   0.0.0.0:49161-&gt;8080/tcp   tomcat02
3219645c299e   tomcat    &quot;catalina.sh run&quot;   43 minutes ago   Up 43 minutes   0.0.0.0:49160-&gt;8080/tcp   tomcat01
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat03 ping tomcat02
PING tomcat02 (172.18.0.3) 56(84) bytes of data.
64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.107 ms
64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.079 ms
64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.083 ms

#反向可以ping通吗？ping不通，只是单向绑定，其实就是hosts映射
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat02 ping tomcat03
ping: tomcat03: Name or service not known
</code></pre>
<p>我们可以通过inspect命令来查看tomcat02和tomcat03之间的关系：<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620221546821-0fca8e48-ee44-422b-863f-cb6e245207a3.png#align=left&amp;display=inline&amp;height=50&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=50&amp;originWidth=308&amp;size=2030&amp;status=done&amp;style=none&amp;width=308" alt="image.png" loading="lazy"><br>
也可以查看容器tomcat03的hosts文件里的配置（本质就是再hosts文件添加了映射）：<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620221705532-958d2115-7ad5-4fd0-8289-08160a9fba91.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=143&amp;originWidth=679&amp;size=13498&amp;status=done&amp;style=none&amp;width=679" alt="image.png" loading="lazy"><br>
<strong>实际开发环境已经不推荐使用--link</strong> <br>
推荐使用自定义网络。</p>
<h2 id="自定义网络">自定义网络</h2>
<blockquote>
<p>查看所有的docker网络</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620226278945-c170f378-ee0c-4c44-8070-21ee6381f5d1.png#align=left&amp;display=inline&amp;height=82&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=82&amp;originWidth=433&amp;size=7831&amp;status=done&amp;style=none&amp;width=433" alt="image.png" loading="lazy"><br>
首先了解一下网络模式：<br>
<strong>桥接模式</strong> ： bridge，就相当于再网络之间搭桥，此处就是使用docker搭桥，比如0.2和0.3通信使用0.1来建立连接<br>
<strong>none</strong> ：不配置网络<br>
<strong>host</strong> ：和宿主机共享网络<br>
<strong>container</strong> ：容器网络连通（不推荐使用）</p>
<p><strong>测试</strong></p>
<pre><code class="language-shell">#我们的直接启动命令是默认使用--net bridge，这个就是docker0
docker run -d -P --name tomcat01 tomcat
docker run -d -P --name tomcat01 --net bridge tomcat

#docker0的特点：
1. 默认时使用docker0的
2.通过容器名是不能访问的
3.通过--link是可以打通连接的

#我们可以使用自定义网络
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker network create -d bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
2c27888ef29de18be748bd0c480dff5ba6a54ab0c4312a34a53055bb5f5dc0ac
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
0982a0bbe121   bridge    bridge    local
c08d78952fae   host      host      local
2c27888ef29d   mynet     bridge    local
175e2e0d6e59   none      null      local
</code></pre>
<p>启动两个容器之后再查看创建的网络，可以看到该网络下有两个刚刚创建的服务：</p>
<pre><code class="language-shell">docker network inspect mynet
[
    {
        &quot;Name&quot;: &quot;mynet&quot;,
        &quot;Id&quot;: &quot;2c27888ef29de18be748bd0c480dff5ba6a54ab0c4312a34a53055bb5f5dc0ac&quot;,
        &quot;Created&quot;: &quot;2021-05-05T23:14:19.563722572+08:00&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: {},
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: false,
        &quot;Ingress&quot;: false,
        &quot;ConfigFrom&quot;: {
            &quot;Network&quot;: &quot;&quot;
        },
        &quot;ConfigOnly&quot;: false,
        &quot;Containers&quot;: {
            &quot;11521b8c79e01a2ddd8f999b3487a6fe47330dd7cdee53ca8b1dd901fcb95dfd&quot;: {
                &quot;Name&quot;: &quot;tomcat-mynet-02&quot;,
                &quot;EndpointID&quot;: &quot;d049aecef238e37d2fbe8120662396b27f7d64ffa267dd6a9b119d47618b5bfb&quot;,
                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;119ad031251c65764c16d62c10ec62aa3bfa08297e391620af71847276478531&quot;: {
                &quot;Name&quot;: &quot;tomcat-mynet-01&quot;,
                &quot;EndpointID&quot;: &quot;07c7ea17f65b1f8ef3c70fa2bb2196135ef11a2e97bd106f75943fe78cdd4dbc&quot;,
                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {}
    }
]
</code></pre>
<p>现在通过ip和服务名都可以ping通：</p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat-mynet-01 ping 192.168.0.3
PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.140 ms
64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.075 ms
64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.089 ms

#现在是可以不通过--link也可以ping通
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat-mynet-01 ping tomcat-mynet-02
PING tomcat-mynet-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-mynet-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.058 ms
64 bytes from tomcat-mynet-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.083 ms
64 bytes from tomcat-mynet-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.097 ms

#我们可以看到两个容器中的hosts都添加了对应的映射
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat-mynet-01 cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
192.168.0.2	119ad031251c
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it tomcat-mynet-02 cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
192.168.0.3	11521b8c79e0
</code></pre>
<p>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐使用这种自定义网络的形式。<br>
好处：<br>
对于不通的集群比如redis和mysql，不同的集群使用不同的网络，保证集群是安全和健康的。</p>
<h2 id="网络连通">网络连通</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620229266904-d8e386a4-f0f0-4ca5-a3b1-bcc39f03260f.png#align=left&amp;display=inline&amp;height=533&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=533&amp;originWidth=742&amp;size=18920&amp;status=done&amp;style=none&amp;width=742" alt="image.png" loading="lazy"><br>
想要tomcat01能够ping通tomcat-mynet-01，这样显然是不行的。<br>
我们可以使用 <code>docker network connect</code>命令来实现</p>
<pre><code class="language-shell">docker network connect mynet tomcat01
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker network inspect mynet
[
    {
        &quot;Name&quot;: &quot;mynet&quot;,
        &quot;Id&quot;: &quot;2c27888ef29de18be748bd0c480dff5ba6a54ab0c4312a34a53055bb5f5dc0ac&quot;,
        &quot;Created&quot;: &quot;2021-05-05T23:14:19.563722572+08:00&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: {},
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: false,
        &quot;Ingress&quot;: false,
        &quot;ConfigFrom&quot;: {
            &quot;Network&quot;: &quot;&quot;
        },
        &quot;ConfigOnly&quot;: false,
        &quot;Containers&quot;: {
            &quot;11521b8c79e01a2ddd8f999b3487a6fe47330dd7cdee53ca8b1dd901fcb95dfd&quot;: {
                &quot;Name&quot;: &quot;tomcat-mynet-02&quot;,
                &quot;EndpointID&quot;: &quot;d049aecef238e37d2fbe8120662396b27f7d64ffa267dd6a9b119d47618b5bfb&quot;,
                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;119ad031251c65764c16d62c10ec62aa3bfa08297e391620af71847276478531&quot;: {
                &quot;Name&quot;: &quot;tomcat-mynet-01&quot;,
                &quot;EndpointID&quot;: &quot;07c7ea17f65b1f8ef3c70fa2bb2196135ef11a2e97bd106f75943fe78cdd4dbc&quot;,
                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;5dfaf5196081035142fe00549ae2a68b5ad44d64f1aa88a8e52a3e041442fe85&quot;: {
                &quot;Name&quot;: &quot;tomcat01&quot;,
                &quot;EndpointID&quot;: &quot;d95c27f4a83d6a856144b4cd90551bd229e1239bbc9b200647bf88e39a85b055&quot;,
                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;,
                &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {}
    }
]
</code></pre>
<p>我们可以看到tomcat-mynet-01是直接加到mynet之下，并分配了一个ip<br>
这其实就是给tomcat-mynet-01分配了两个ip，就像阿里云服务器一个公网ip和一个私网ip</p>
<h2 id="实战redis集群部署">实战：redis集群部署</h2>
<figure data-type="image" tabindex="4"><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1620229758691-f87964f9-a319-4d51-a8ae-4b4420adeec2.png#align=left&amp;display=inline&amp;height=392&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=783&amp;originWidth=1314&amp;size=103161&amp;status=done&amp;style=none&amp;width=657" alt="image.png" loading="lazy"></figure>
<h1 id="计划看完redis再来实践">计划看完redis再来实践！！！</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker-基础篇（一）]]></title>
        <id>https://gushi1912.github.io/post/docker-ji-chu-pian-yi/</id>
        <link href="https://gushi1912.github.io/post/docker-ji-chu-pian-yi/">
        </link>
        <updated>2021-03-28T09:27:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="docker概念">Docker概念</h1>
<p><strong>Hypervisor虚拟化技术的介绍</strong> ： <a href="https://www.jianshu.com/p/b9900b9dec34">https://www.jianshu.com/p/b9900b9dec34</a></p>
<blockquote>
<p>Docker在虚拟化的容器中增加了一个应用程序部署引擎。该引擎的目标就是提供一个轻量的，快速的环境，能够运行开发者的程序，并方便高效地将程序从开发者的笔记本部署到测试环境，然后再部署到正式环境。<br>
---《第一本Docker书》</p>
</blockquote>
<ul>
<li>Docker提供了一个简单，轻量的建模方式</li>
<li>职责的逻辑分离</li>
<li>快速、高效的开发生命周期</li>
<li>鼓励使用面向服务的架构</li>
</ul>
<p>Docker是一个CS架构的程序。Docker客户端只需要向Docker服务器或者Docker守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。</p>
<blockquote>
<p>守护进程就是在后台运行的进程，通常负责系统上的某个服务，让系统接收来自用户或者是网络客户的要求。守护进程的名字一般是以 d 结尾。<br>
参考：<a href="https://segmentfault.com/a/1190000015384291">https://segmentfault.com/a/1190000015384291</a></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1614909156069-c83f3980-c700-4312-9bcb-d58b3eac99f1.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=704&amp;originWidth=618&amp;size=378618&amp;status=done&amp;style=none&amp;width=309" alt="image.png" loading="lazy"><br>
<strong>images</strong> ：镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。可以把镜像视为容器的“源代码”。<br>
<strong>container</strong> : ：Docker利用容器技术可以独立运行一个或者一组应用，它是通过镜像创建的。容器可以启动，停止，删除。可以把容器理解为一个简易的Linux系统。Docker可以帮助我们构建和部署容器，我们只需要把自己的应用程序打包放进容器内部即可。容器是基于镜像启动起来的，容器可以运行一个或者多个进程。<br>
<strong>使用镜像创建容器的流程</strong></p>
<blockquote>
<p>Docker首先会检查本机中是否存在该镜像，本地如果没有这个镜像，那么Docker就会链接官方维护的Docker Hub Registry，查看Docker Hub中是否有该镜像。Docker找到该镜像就会下载该镜像到本地将其保存到宿主机中。</p>
</blockquote>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1614925284659-591d6c14-b9ae-4c6f-9db0-364ba242d47c.png#align=left&amp;display=inline&amp;height=487&amp;margin=%5Bobject%20Object%5D&amp;name=Docker%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png&amp;originHeight=973&amp;originWidth=948&amp;size=100471&amp;status=done&amp;style=stroke&amp;width=474" alt="Docker运行流程.png" loading="lazy"></strong><br>
<strong>Registry</strong> : registry是提供存储镜像服务的仓库。最大的共有仓库是官方的Dockerhub，我们当然也可以创建自己的私人仓库。用户可以在Docker Hub上注册账号，分析并保存自己的镜像。</p>
<blockquote>
<p>Docker registry is a service that is storing your docker images.</p>
</blockquote>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1614911782738-6907f76c-8a9c-4d42-97cd-255c8c49afcf.png#align=left&amp;display=inline&amp;height=55&amp;margin=%5Bobject%20Object%5D&amp;name=20200812111639480.png&amp;originHeight=55&amp;originWidth=165&amp;size=1490&amp;status=done&amp;style=none&amp;width=165" alt="20200812111639480.png" loading="lazy"></strong><br>
<strong>Repository</strong> ： 仓库中存放的是名字相同但是tag不同的镜像。</p>
<blockquote>
<p>Docker repository is a collection of different images with same name, that have different tags.</p>
</blockquote>
<p>可以从Docker的图标来理解，Registry就可以理解为图标中的那个大鲸鱼，大鲸鱼的背上有很多集装箱，集装箱中一般装的都是同类商品，集装箱就可以理解为Repository。</p>
<pre><code>Docker是怎么工作的？
Docker是一个CS结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端进行访问。
Docker-server接收到Docker-client的指令，就会执行这条指令。

Docker为什么比VM快？
1.Docker比虚拟机有更少的抽象层。
2.Docker利用的是宿主机内核，VM需要的是GuestOS。所以说，新建一个容器的时候，docker不需要像虚拟机那样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，docker是利用宿主机的操作系统，省略了这个复杂的过程。
</code></pre>
<h1 id="docker安装">Docker安装</h1>
<p>参考文档：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<ol>
<li><strong>如果系统中安装了旧版本的docker，需要卸载掉，执行以下命令：</strong></li>
</ol>
<pre><code class="language-shell"> sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
</code></pre>
<p>yum提示没有相关包安装过，说明系统中没有安装过旧版本的docker。</p>
<blockquote>
<p>使用yum安装Docker的安装目录在/var/lib/docker中，移除之前版本docker的时候目录中的images，containers，volumes以及networks被保留没有删除。<br>
Docker引擎现在被命名为docker-ce</p>
</blockquote>
<ol start="2">
<li><strong>使用仓库源安装（推荐使用）</strong></li>
</ol>
<pre><code class="language-shell">#安装yum-utils包，改包提供了yum-config-manager工具
sudo yum install -y yum-utils
#设置镜像仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

#此处使用的是官方的仓库地址，速度比较慢，推荐使用国内的镜像地址，例如阿里云的仓库：
http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<ol start="3">
<li><strong>安装最新版本的docker引擎（社区版）以及容器</strong></li>
</ol>
<pre><code class="language-shell">sudo yum -y install docker-ce docker-ce-cli containerd.io
</code></pre>
<blockquote>
<p>有多个Docker仓库吗？<br>
如果启用了多个Docker仓库，则在未在yum install或者yum update命令中指定版本的情况下，进行的安装或者更新总是最新版本的，这可能不适合您的稳定性需求。</p>
</blockquote>
<p>Docker安装完默认未启动。并且已经创建好docker用户组，但是还没有在该用户组下添加用户。<br>
安装特定版本的Docker引擎，请在存储库中列出可用版本，然后选择并安装 。<br>
3.1 列出并排序您存储库中可用的版本。此示例按版本号从高到低对结果进行排序</p>
<pre><code class="language-shell">yum list docker-ce --showduplicates | sort -r
docker-ce.x86_64            3:20.10.5-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:20.10.5-3.el7                    @docker-ce-stable
docker-ce.x86_64            3:20.10.4-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:20.10.3-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:20.10.2-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:20.10.1-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:20.10.0-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:19.03.9-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:19.03.8-3.el7                    docker-ce-stable 
...
</code></pre>
<p>3.2 通过其完整的软件安装包名称安装特定版本。完整软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号一直到第一个连字符，并用连字符（-）分隔。例如：<strong>docker-ce-10.10.5</strong></p>
<pre><code class="language-shell">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io
</code></pre>
<ol start="4">
<li><strong>启动docker</strong></li>
</ol>
<pre><code class="language-shell">sudo systemctl start docker
</code></pre>
<ol start="5">
<li><strong>通过运行hello-world镜像来验证是否正确安装。</strong></li>
</ol>
<pre><code class="language-shell">sudo docker run hello-world
</code></pre>
<p><strong>配置镜像加速器</strong> <br>
阿里云服务器页面中，寻找容器镜像服务中的镜像加速器。<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1615636291167-b72dca63-a571-41bd-badf-c6d1dcc2a693.png#align=left&amp;display=inline&amp;height=586&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1171&amp;originWidth=1271&amp;size=176772&amp;status=done&amp;style=none&amp;width=635.5" alt="image.png" loading="lazy"></p>
<h1 id="docker命令">Docker命令</h1>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/2907980/1615624148373-8735ce7c-d2b9-4e86-854b-02869a67d4b9.jpeg#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;name=%E5%91%BD%E4%BB%A4.jpeg&amp;originHeight=540&amp;originWidth=720&amp;size=49039&amp;status=done&amp;style=none&amp;width=720" alt="命令.jpeg" loading="lazy"></figure>
<h2 id="帮助命令">帮助命令</h2>
<pre><code class="language-shell">docker version     # 显示docker的版本信息
docker info        # 显示docker的系统信息，包括镜像和容器的数量
docker 命令 --help # 帮助指令
</code></pre>
<p>官方命令介绍：<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
<hr>
<h2 id="镜像命令">镜像命令</h2>
<p><strong>docker images</strong> <strong>[options] repository[:tag]</strong>: <strong>查看本地主机上的所有镜像</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
hello-world   latest    bf756fb1ae65   14 months ago   13.3kB
#解释
REPOSITORY 镜像的仓库源
TAG        镜像的标签
INAGE ID   镜像的id
CREATED    镜像的创建时间
SIZE       镜像的大小

#可选项
-a，--all    显示所有的镜像
-q，--quite  只显示镜像id

repository[:tag] 对搜索镜像的所属仓库和标签做限制
</code></pre>
<p><strong>docker search [options]</strong> : <strong>从仓库中搜索镜像</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   10563     [OK]       
mariadb                           MariaDB Server is a high performing open sou…   3947      [OK]       
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   774                  [OK]
percona                           Percona Server is a fork of the MySQL relati…   527       [OK]       
centos/mysql-57-centos7           MySQL 5.7 SQL database server                   87                   
mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   79                   

#可选项
--filter=STARS=3000 搜索STARS大于3000的镜像（注意是 = ）
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker search mysql --filter=STARS&gt;3000
invalid argument &quot;STARS&quot; for &quot;-f, --filter&quot; flag: bad format of filter (expected name=value)
See 'docker search --help'.
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   10563     [OK]       
mariadb   MariaDB Server is a high performing open sou…   3947      [OK]      
</code></pre>
<p><strong>docker pull [options] name[:tag|@digest]</strong> : <strong>下载镜像</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker pull mysql
Using default tag: latest     #如果不写tag，默认就是latest
latest: Pulling from library/mysql
a076a628af6f: Pull complete   # 分层下载，docker images的核心  联合文件系统
f6c208f3f991: Pull complete 
88a9455a9165: Pull complete 
406c9b8427c6: Pull complete 
7c88599c0b25: Pull complete 
25b5c6debdaf: Pull complete 
43a5816f1617: Pull complete 
1a8c919e89bf: Pull complete 
9f3cf4bd1a07: Pull complete 
80539cea118d: Pull complete 
201b3cad54ce: Pull complete 
944ba37e1c06: Pull complete 
Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest   # 真实地址

docker pull mysql
等价于
docker pull docker.io/library/mysql:latest

# 指定版本系统
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
a076a628af6f: Already exists   #公用的部分就不用下载 联合文件系统
f6c208f3f991: Already exists 
88a9455a9165: Already exists 
406c9b8427c6: Already exists 
7c88599c0b25: Already exists 
25b5c6debdaf: Already exists 
43a5816f1617: Already exists 
1831ac1245f4: Pull complete 
37677b8c1f79: Pull complete 
27e4ac3b0f6e: Pull complete 
7227baa8c445: Pull complete 
Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7
</code></pre>
<p><strong>docker rmi [options] image</strong> : <strong>删除镜像(可以通过镜像ID删除也可以通过镜像名删除)</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker rmi -f a70d36bc331a  # -f表示删除全部
Untagged: mysql:5.7
Untagged: mysql@sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df
Deleted: sha256:a70d36bc331a13d297f882d3d63137d24b804f29fa67158c40ad91d5050c39c5
Deleted: sha256:50c77bf7bcddd1f1d97789d80ac2404eec22c860c104e858620d2a2e321f0ef7
Deleted: sha256:14244329b83dfc8982398ee4104a548385652d2bffb957798ff86a419013efd6
Deleted: sha256:6d990477f90af28473eb601a9bca22253f6381e053c5a8edda0a4f027e124a3c
Deleted: sha256:ee0449796df204071589162fc16f8d65586312a40c68d1ba156c93c56f5e5ce8
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker rmi -f $(docker images -aq)  # 通过查询出来的镜像ID来全部删除
Untagged: mysql:latest
Untagged: mysql@sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c
Deleted: sha256:c8562eaf9d81c779cbfc318d6e01b8e6f86907f1d41233268a2ed83b2f34e748
Deleted: sha256:1b649b85960473808c6b812fc30c3f6a3ff1c0ffdcba5c9435daf01cf7d5373a
Deleted: sha256:19cc889447050c16c797fd209fa114ee219de23facb37c00d4137a4ed4aad922
Deleted: sha256:3c793c06a026d276cf56a6a6a75527026ed9eafa7a7d21a438f7d5ed2314148e
Deleted: sha256:1e1cd89a2bc183a7fea3dab0b543e9924278321ad0921c22cc088adbf3c2e77b
Deleted: sha256:83b2015dfd000588c7c947b2d89b3be7a8e5a3abc6ab562668c358033aa779ec
Deleted: sha256:d08533f1e2acc40ad561a46fc6a76b54c739e6b24f077c183c5709e0a6885312
Deleted: sha256:4f9d91a4728e833d1062fb65a792f06e22e425f63824f260c8b5a64b776ddc38
Deleted: sha256:20bf4c759d1b0d0e6286d2145453af4e0e1b7ba3d4efa3b8bce46817ad4109de
Deleted: sha256:a9371bbdf16ac95cc72555c6ad42f79b9f03a82d964fe89d52bdc5f335a5f42a
Deleted: sha256:5b02130e449d94f51e8ff6e5f7d24802246198749ed9eb064631e63833cd8f1d
Deleted: sha256:ab74465b38bc1acb16c23091df32c5b7033ed55783386cb57acae8efff9f4b37
Deleted: sha256:cb42413394c4059335228c137fe884ff3ab8946a014014309676c25e3ac86864
Untagged: hello-world:latest
Untagged: hello-world@sha256:7e02330c713f93b1d3e4c5003350d0dbe215ca269dd1d84a4abc577908344b30
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
</code></pre>
<hr>
<h2 id="容器命令">容器命令</h2>
<p><strong>说明：有了镜像才会有容器。例子：linux，下载一个centos镜像</strong></p>
<pre><code class="language-shell">docker pull centos
</code></pre>
<p><strong>创建容器并启动</strong> <br>
<strong>docker run [optinos] image [command] [args...]</strong></p>
<blockquote>
<p>Docker在文件系统内部用这个镜像创建了一个新的容器。该容器拥有自己的网络、IP地址，以及一个用来和宿主机进行通信的桥接网络接口。</p>
</blockquote>
<pre><code class="language-shell">docker run -it centos /bin/bash
# 可选参数
--name 容器名字    容器名字，用来区分容器，如果名字已经存在，可以删除原有容器，再重新创建新容器
-d                后台方式运行（守护方式运行容器）
-it               使用交互方式运行，进入容器查看内容
-p                指定容器的端口 -p 8080:8080
	-p ip:主机端口:容器端口
	-p 主机端口:容器端口（映射）-常用
  -p 容器端口
-P                随机指定端口
-i            标志容器中STDIN是开启的
-t            告诉Docker为要创建的容器分配一个伪tty终端
/bin/bash：表示我们在容器中运行/bin/bash命令启动了一个Bash Shell

#测试
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker run -it centos /bin/bash  #启动并进入容器
[root@58a715a67e2b /]# 
[root@58a715a67e2b /]# ls       #容器内部
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@58a715a67e2b /]# exit
exit
只有在指定的/bin/bash命令处于运行状态的时候，容器才会响应的处于运行状态，一旦退出容器，/bin/bash命令也纠结束了，这个时候容器也就随之停止运行了。
</code></pre>
<p><strong>docker ps [options]</strong> : 列出所有运行的容器</p>
<pre><code class="language-shell">#docker ps 列出当前正在运行的容器
-a      #列出当前正在运行的容器以及历史运行过的容器
-n=？   #显示最近创建的容器
-q      #只显示容器的id
-l      #列出最近一次使用的容器，包括正在运行的和停止的

[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                       PORTS     NAMES
58a715a67e2b   centos         &quot;/bin/bash&quot;   4 minutes ago   Exited (127) 3 minutes ago             agitated_booth
a91bc75ed0fc   bf756fb1ae65   &quot;/hello&quot;      7 hours ago     Exited (0) 7 hours ago                 tender_matsumoto
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps -aq
58a715a67e2b
a91bc75ed0fc
</code></pre>
<ul>
<li><strong>CONTAINER ID : 容器ID</strong></li>
<li><strong>IMAGE: 创建该容器的镜像</strong></li>
<li><strong>COMMAND: 容器最后执行的命令</strong></li>
<li><strong>CREATED: 创建时间</strong></li>
<li><strong>STATUS: 容器的退出状态</strong></li>
<li><strong>PORTS: 容器的端口信息和连接类型（tcp/udp）</strong></li>
<li><strong>NAMES: 容器的名称（随机生成，也可以指定名称）</strong></li>
</ul>
<p><strong>docker rm [options]</strong> : 删除容器</p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker rm 427a27ce6924
Error response from daemon: You cannot remove a running container 427a27ce6924f5a996963cf927038cbc2470c7297ba87adc3ea75ec5588f6dce. Stop the container before attempting removal or force remove
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker rm -f 427a27ce6924
427a27ce6924

docker rm 容器id                   #删除指定的容器，但不能删除正在运行的容器
docker rm -f $(docker ps -aq)      #删除所有的容器
docker ps -a -q | xargs docker rm  #删除所有的容器
</code></pre>
<p><strong>退出容器</strong></p>
<pre><code class="language-shell">exit          #直接停止并退出容器
ctrl + P + Q  #退出容器但不停止容器（大写）
</code></pre>
<p><strong>启动和停止容器</strong></p>
<pre><code class="language-shell">docker start 容器id        #启动容器
docker restart 容器id      #重启容器,重启时会沿用docker run命令时指定的参数来运行
#此时我们可以使用attach命令来重新附着到该容器的会话上。
docker stop 容器id         #停止当前正在运行的容器
docker kill 容器id         #杀掉当前容器
</code></pre>
<hr>
<h2 id="常用其他命令">常用其他命令</h2>
<p><strong>后台启动容器</strong> ： <strong>docker run -d</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker run -d centos
f497ef3afec9c3cc353227f861b9c59f92dc7aea0c4bf6e30b4fd230594e2a91
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
 
 #问题：执行docker ps命令之后，发现没有服务启动
 #原因：docker容器使用后台运行，就必须要有一个前台进程，容器启动之后docker发现没有提供服务就会自动停止该服务。
 #常见的有nginx，容器启动之后发现自己没有提供服务就会立刻停止。
</code></pre>
<p><strong>查看日志</strong> ： <strong>docker logs</strong></p>
<pre><code class="language-shell">#自己编写一段shell脚本
docker run -d centos /bin/bash -c &quot;while true;do echo gugugu;sleep 1;done&quot;
c0a47e8df8c8afcee743da29ca79caabdf41c5a74fafc845639278f96f3bd3dc
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
c0a47e8df8c8   centos    &quot;/bin/bash -c 'while…&quot;   3 seconds ago   Up 2 seconds             eloquent_rosalind

-f   # 持续输出日志
-n   # 输出倒数多少行日志
-t   # 打印日志时间戳

[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker logs -f -t -n 10 c0a47e8df8c8 
2021-03-04T14:29:48.767502249Z gugugu
2021-03-04T14:29:49.770016705Z gugugu
2021-03-04T14:29:50.772238826Z gugugu
2021-03-04T14:29:51.774390995Z gugugu
2021-03-04T14:29:52.776769049Z gugugu
2021-03-04T14:29:53.779520016Z gugugu
2021-03-04T14:29:54.781739693Z gugugu
2021-03-04T14:29:55.784002387Z gugugu
</code></pre>
<p><strong>查看容器中的进程信息</strong> ： <strong>docker top 容器ID</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker top efe256694120
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                3674                3654                0                   22:47               ?                   00:00:00            /bin/bash -c while true;do echo gugugu;sleep 1;done
root                3754                3674                0                   22:47               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
</code></pre>
<p><strong>查看镜像元数据： docker inspect 容器ID</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker inspect -s efe256694120
[
    {
        &quot;Id&quot;: &quot;efe2566941202be29f7a1649603df457fd13c2ab99949a4c5d3056886d7a7b09&quot;,
        &quot;Created&quot;: &quot;2021-03-04T14:47:07.794562741Z&quot;,
        &quot;Path&quot;: &quot;/bin/bash&quot;,
        &quot;Args&quot;: [
            &quot;-c&quot;,
            &quot;while true;do echo gugugu;sleep 1;done&quot;
        ],
        &quot;State&quot;: {
            &quot;Status&quot;: &quot;running&quot;,
            &quot;Running&quot;: true,
            &quot;Paused&quot;: false,
            &quot;Restarting&quot;: false,
            &quot;OOMKilled&quot;: false,
            &quot;Dead&quot;: false,
            &quot;Pid&quot;: 3674,
            &quot;ExitCode&quot;: 0,
            &quot;Error&quot;: &quot;&quot;,
            &quot;StartedAt&quot;: &quot;2021-03-04T14:47:08.252294439Z&quot;,
            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;
        },
        &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;,
        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/efe2566941202be29f7a1649603df457fd13c2ab99949a4c5d3056886d7a7b09/resolv.conf&quot;,
        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/efe2566941202be29f7a1649603df457fd13c2ab99949a4c5d3056886d7a7b09/hostname&quot;,
        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/efe2566941202be29f7a1649603df457fd13c2ab99949a4c5d3056886d7a7b09/hosts&quot;,
        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/efe2566941202be29f7a1649603df457fd13c2ab99949a4c5d3056886d7a7b09/efe2566941202be29f7a1649603df457fd13c2ab99949a4c5d3056886d7a7b09-json.log&quot;,
......
 &quot;NetworkSettings&quot;: {
            &quot;Bridge&quot;: &quot;&quot;,
            &quot;SandboxID&quot;: &quot;81048d6df7ed46671cfba5ad5bf513c4516de659a31ff0772484a54229096a15&quot;,
            &quot;HairpinMode&quot;: false,
            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,
            &quot;LinkLocalIPv6PrefixLen&quot;: 0,
            &quot;Ports&quot;: {},
            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/81048d6df7ed&quot;,
            &quot;SecondaryIPAddresses&quot;: null,
            &quot;SecondaryIPv6Addresses&quot;: null,
            &quot;EndpointID&quot;: &quot;6a9fe472a625f284f57fe08f0ce5361f1e28dd1c46360791056ed05dcdf9cf9e&quot;,
            &quot;Gateway&quot;: &quot;172.18.0.1&quot;,
            &quot;GlobalIPv6Address&quot;: &quot;&quot;,
            &quot;GlobalIPv6PrefixLen&quot;: 0,
            &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,
            &quot;IPPrefixLen&quot;: 16,
            &quot;IPv6Gateway&quot;: &quot;&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
            &quot;Networks&quot;: {
                &quot;bridge&quot;: {
                    &quot;IPAMConfig&quot;: null,
                    &quot;Links&quot;: null,
                    &quot;Aliases&quot;: null,
                    &quot;NetworkID&quot;: &quot;a48fe4b62dfe5c2edb09cb5d5ea06ddd22206d1bef02c9cce6316636c6605f93&quot;,
                    &quot;EndpointID&quot;: &quot;6a9fe472a625f284f57fe08f0ce5361f1e28dd1c46360791056ed05dcdf9cf9e&quot;,
                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;,
                    &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,
                    &quot;IPPrefixLen&quot;: 16,
                    &quot;IPv6Gateway&quot;: &quot;&quot;,
                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,
                    &quot;GlobalIPv6PrefixLen&quot;: 0,
                    &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
                    &quot;DriverOpts&quot;: null
                }
            }
        }
    }
]
</code></pre>
<p><strong>进入当前正在运行的容器</strong> <br>
容器通常都是使用后台方式运行的，要进入容器需要修改一些配置。</p>
<pre><code class="language-shell">#第一种方式
docker exec -it 容器id bash/shell

[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker exec -it efe256694120 /bin/bash
[root@efe256694120 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@efe256694120 /]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 14:47 ?        00:00:00 /bin/bash -c while true;do echo gugugu;sleep 1;done
root      1255     0  0 15:07 pts/0    00:00:00 /bin/bash
root      1278     1  0 15:08 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
root      1279  1255  0 15:08 pts/0    00:00:00 ps -ef

#第二种方式
docker attach 容器id

#区别
#docker exec     # 进入容器之后开启一个新的终端，可以在里面正常操作
#docker attach   # 进入容器正在执行的终端，不会启动新的进程(退出容器shell之后，容器就会停止)
</code></pre>
<p><strong>从容器内部拷贝文件到主机：docker cp 容器ID:/path /(out)path</strong><br>
<strong>从宿主机拷贝文件到容器目录：docker cp /(out)path 容器ID:/path</strong></p>
<pre><code class="language-shell">[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker run -it centos /bin/bash
[root@1b6ed260413d /]# cd /home
[root@1b6ed260413d home]# touch test.java
[root@1b6ed260413d home]# ls
test.java
[root@1b6ed260413d home]# exit
exit
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker ps -a
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                            PORTS     NAMES
1b6ed260413d   centos    &quot;/bin/bash&quot;              45 seconds ago   Exited (0) 16 seconds ago                   zealous_kepler
efe256694120   centos    &quot;/bin/bash -c 'while…&quot;   28 minutes ago   Exited (137) About a minute ago             gifted_carson
c0a47e8df8c8   centos    &quot;/bin/bash -c 'while…&quot;   46 minutes ago   Exited (137) 45 minutes ago                 eloquent_rosalind
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# dokcer cp 1b6ed260413d:/home/test.java /home
-bash: dokcer: command not found
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker cp 1b6ed260413d:/home/test.java /home
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# cd /home
[root@iZuf6e1jhv5i6fv2ux4x53Z home]# ll
total 4
drwx------ 3 admin admin 4096 Jan 15 13:38 admin
-rw-r--r-- 1 root  root     0 Mar  4 23:15 test.java
</code></pre>
<p><strong>容器自动重启</strong> <br>
使用 <code>--restart</code> 命令使容器在错误退出的时候能自动重启</p>
<pre><code class="language-shell">docker run -d --restart=always --name xxxx centos /bin/sh -c &quot;while true;do echo hello;sleep 1;done&quot;
#always表示无论什么情况下都会自动重启
#on-failure表示只有在容器的退出代码为非0值的时候才会自动重启
#on-failure:number  最多重启num次
</code></pre>
<p><strong>TIPS</strong></p>
<pre><code class="language-shell">#Tomcat 官方推荐使用以下命令运行tomcat
docker run -it --rm tomcat:9.0
--rm    # 我们之前启动都是后台启动，停止容器之后容器还是可以查到，该命令是用完就会删除容器，一般用来测试

#Elasticsearch 
#es暴露的端口很多，非常消耗内存，且es的数据一般需要放在安全目录，挂载
docker network create somenetwork
docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag
#下载运行之后我们可以使用以下命令来查看CPU，内存等占用情况
docker stats 容器id/容器名
#测试es是否启动成功
curl localhost:9200
[root@iZuf6e1jhv5i6fv2ux4x53Z docker]# curl localhost:9200
{
  &quot;name&quot; : &quot;8d8329ecc2d1&quot;,
  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,
  &quot;cluster_uuid&quot; : &quot;lnjqmGwvT5uPNJ63RpSjww&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;7.10.1&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;docker&quot;,
    &quot;build_hash&quot; : &quot;1c34507e66d7db1211f66f3513706fdf548736aa&quot;,
    &quot;build_date&quot; : &quot;2020-12-05T01:00:33.671820Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.7.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}

#为避免es占用内存太多情况，可以在启动的时候外挂配置增加内存限制
docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;ES_JAVA_OPTS=-Xms64m -Xmx512m&quot; elasticsearch:tag
</code></pre>
<h1 id="docker镜像解析">Docker镜像解析</h1>
<h2 id="镜像是什么">镜像是什么</h2>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容、包括代码、运行时库、环境变量和配置文件（所有的应用打包成docker镜像就可以直接跑起来）。</p>
<h2 id="docker镜像加载原理">Docker镜像加载原理</h2>
<blockquote>
<p>联合文件系统</p>
</blockquote>
<p>UnionFS(联合文件系统)：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像）可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终文件系统会包含所有底层的文件和目录。我们拉取镜像的时候就可以看到是多个文件同时下载，并不是一整个文件。</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫做UnionFS。<br>
<strong>一个典型的Linux文件系统由bootfs和rootfs两部分组成</strong> <br>
bootfs（boot file system）主要包含bootloader（启动类加载器）和kernel（内核），bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与典型的Linux/Unix系统是一样的，包含boot加载器的内核。当boot加载完成之后整个内核就都在内存之中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载（unmount）bootfs。<br>
rootfs（root file system）在bootfs之上。包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版。比如Ubuntu、Centos等。<br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1615624127264-0293b64f-1a00-4939-856a-b5438b42b6b0.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86.png&amp;originHeight=287&amp;originWidth=932&amp;size=113224&amp;status=done&amp;style=none&amp;width=932" alt="镜像原理.png" loading="lazy"></p>
<h2 id="分层理解">分层理解</h2>
<p>Docker0.7之后引入了Storage Driver（存储驱动），现在已经支持AUFS、Brtfs、Devicemapper、OverlayFS（centos使用）、ZFS、VFS。<br>
参考连接：<a href="https://www.cnblogs.com/jhxxb/p/11430938.html">https://www.cnblogs.com/jhxxb/p/11430938.html</a><br>
<a href="https://blog.51cto.com/13887323/2551061">https://blog.51cto.com/13887323/2551061</a>（主要）</p>
<p>镜像里的联合文件系统可以将几层目录挂载到一起（就像千层饼，这个比喻后面还会用到）形成一个虚拟的文件系统，虚拟的文件系统的目录结构就像Linux的目录结构，镜像通过这些虚拟的目录结构和宿主机的内核一起构成了一个虚拟环境，每一层的系统文件叫做layer 。<br>
<strong>可以通过docker inspect 镜像来查看layer中的层级</strong> <br>
<img src="https://cdn.nlark.com/yuque/0/2021/png/2907980/1615650945071-16c1c347-6566-44d0-b8bf-69f7bdaf3aa2.png#align=left&amp;display=inline&amp;height=379&amp;margin=%5Bobject%20Object%5D&amp;name=%E5%88%86%E5%B1%82.png&amp;originHeight=379&amp;originWidth=1220&amp;size=29423&amp;status=done&amp;style=none&amp;width=1220" alt="分层.png" loading="lazy"><br>
联合文件系统可以对每一层的文件设置三种权限： <code>只读（readonly）</code> 、 <code>读写（readwrite）</code> 、 <code>写出（writeout）</code>。<br>
<strong>镜像中的每一层都是 只读 的</strong>，构建镜像的时候，从一个最基本的操作系统开始，每个构建提交的操作都相当于做一层的修改，增加 了一层文件系统，一层层往上叠加， <strong>上层的修改会覆盖底层位置的可见性</strong> 。<br>
Docker镜像可以视为Docker容器的静态时，也可以将Docker容器视为Docker镜像的运行态。</p>
<p><strong>容器的可写层</strong> <br>
当容器启动的时候，一个新的可写层就被加到镜像的可读层之上，这一层通常叫做容器曾，容器层之下的就叫做镜像层。<br>
所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。<br>
<strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的（就相当于我们在千层饼上随意抹自己喜欢的酱）。</strong><br>
下面我们深入讨论容器层的细节。</p>
<ol>
<li>
<p><strong>添加文件</strong></p>
<p>在容器中创建文件时，新文件被添加到容器层中。</p>
</li>
<li>
<p><strong>读取文件</strong></p>
<p>在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</p>
</li>
<li>
<p><strong>修改文件</strong></p>
<p>在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p>
</li>
<li>
<p><strong>删除文件</strong></p>
<p>在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p>
</li>
</ol>
<h2 id="docker-commit">Docker commit</h2>
<p>使用docker commit可以将一个容器提交成为一个新的镜像，这是构建属于自己的镜像的一种简单方式，但是并不推荐使用这种方式来构建镜像。<br>
一般使用 <code>Dockerfile</code>  和 <code>docker build</code> 命令来构建个人镜像，这将在下一篇介绍。</p>
<pre><code class="language-shell">docker commit 提交容器成为一个新的副本
#命令和git原理类似
docker commit -m &quot;提交的描述信息&quot; -a &quot;作者&quot; 容器id 目标镜像名:[TAG]

#实际操作
#启动一个tomcat容器
docker run --name tomcat -d -p 8080:8080 tomcat 
#启动之后发现tomcat服务里的webapps目录里是没有文件的，文件都在webapps.dist目录里
#从webapps.dist目录里拷贝文件到webapps里
cp -r webappps.dist/* webapps
#然后使用commit提交生成一个新的镜像
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker commit -m &quot;add webapps app&quot; -a &quot;gugugu&quot; tomcat tomcat01:GU
sha256:58ed273bfacf861b2c65020b5837ec492856f8258abdb6e6631dcdfa5e145dbc
[root@iZuf6e1jhv5i6fv2ux4x53Z ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat01      GU        58ed273bfacf   3 seconds ago   654MB
hello-world   latest    d1165f221234   8 days ago      13.3kB
tomcat        latest    040bdb29ab37   8 weeks ago     649MB
nginx         latest    f6d0b4767a6c   2 months ago    133MB

#如果想要保存当前容器的状态可以使用commit命令来保存当前状态并生成一个镜像
#就像保存一个快照！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maven笔记]]></title>
        <id>https://gushi1912.github.io/post/maven-bi-ji/</id>
        <link href="https://gushi1912.github.io/post/maven-bi-ji/">
        </link>
        <updated>2021-02-27T11:08:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="maven概述">Maven概述</h2>
<p>Maven是一个项目管理工具，它包含了一个项目对象模型（POM：Project Object Model），一组标准集合，一个项目生命周期（Project Lifiecycl），一个依赖管理系统（Dependency Management System），和用来运行定义在生命周期阶段（phase）中插件（plugin）目标（goal）的逻辑。简单来说，Maven是一个项目管理工具，可以对Java<strong>项目进行构建</strong>，<strong>依赖管理</strong>。</p>
<h2 id="maven安装">Maven安装</h2>
<ol>
<li>Maven是基于Java的，所以在安装Maven之前首先要安装jdk（maven3.3版本对应jdk版本1.7以上）。</li>
<li>windows下载对应的 <strong>.zip</strong> 版本的maven，Linux下载对应的 <strong>.tar.gz</strong> 版本的maven。</li>
<li>windows安装完毕之后，需要在系统环境变量中添加MAVEN_HOME，值为：D:\Dev_Software\apache-maven-3.6.3(maven的安装路径),然后在path中添加%MAVEN_HOME%\bin。</li>
</ol>
<p>Linux在解压之后，需要在/etc/profile中配置环境变量：</p>
<pre><code class="language-shell">wget https://downloads.apache.org/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz
tar -zxvf apache-maven-3.6.3-bin.tar.gz
mv apache-maven-3.6.3 /usr/local
vim /etc/profile
####添加以下内容
export MAVEN_HOME=/usr/local/apache-maven-3.6.3
export PATH=${PATH}:${MAVEN_HOME}/bin
####保存文件
source /etc/profile 
</code></pre>
<h2 id="maven详解">Maven详解</h2>
<h3 id="pom文件">pom文件</h3>
<p>一个最基本的POM文件构成：</p>
<pre><code class="language-xml">&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
 
    &lt;!-- 模型版本 --&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;
    &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;
 
    &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;
    &lt;artifactId&gt;project&lt;/artifactId&gt;
 
    &lt;!-- 版本号 --&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/project&gt;
</code></pre>
<p>每个POM文件都会继承一个父POM，默认的父POM文件的路径是../pom.xml。当有指定 的<parent>标签的时候就睡覆盖默认的父POM。我们可以使用以下命令来查看继承父POM之后，最终生成的POM文件。</p>
<pre><code class="language-shell">mvn help:effecive-pom
</code></pre>
<p>POM文件各标签具体意思可参考该链接：<a href="https://www.runoob.com/maven/maven-pom.html">https://www.runoob.com/maven/maven-pom.html</a></p>
<h3 id="配置文件">配置文件</h3>
<p>maven包含三个标准的生命周期（三套生命周期相互独立）：<br>
<strong>clean：清理编译或者打包后生成的文件 。包含：pre-clean,clean, post-clean.</strong></p>
<ul>
<li><strong>pre-clean:执行clean之前的一些准备操作</strong></li>
<li><strong>clean：清除上次生成的class文件以及一些jar/war包之类的</strong></li>
<li><strong>post-clean：执行clean之后的一些操作</strong></li>
</ul>
<p><strong>default：default阶段包含validate，compile，test，package，verify，install，deploy</strong> ，详细信息见下表。</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>处理</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>validate</td>
<td>验证项目</td>
<td>验证项目是否正确且所有必须信息是否可用</td>
</tr>
<tr>
<td>compile</td>
<td>执行编译</td>
<td>源代码编译阶段在此执行</td>
</tr>
<tr>
<td>Test</td>
<td>测试</td>
<td>使用合适的单元测试框架运行测试</td>
</tr>
<tr>
<td>package</td>
<td>打包</td>
<td>创建jar/war包</td>
</tr>
<tr>
<td>verify</td>
<td>检查</td>
<td>对集成测试的结果进行检查，以保证达标</td>
</tr>
<tr>
<td>install</td>
<td>安装</td>
<td>安装打包的项目到本地仓库，以供其他项目使用</td>
</tr>
<tr>
<td>deploy</td>
<td>部署</td>
<td>拷贝最终的工程包到远程仓库，以供其他开发人员或者项目使用</td>
</tr>
</tbody>
</table>
<p><strong>site:项目站点文档创建的处理</strong> （一般很少使用）<strong>。 包含pre-site,site,post-size,site-deploy。</strong></p>
<ul>
<li><strong>pre-site     执行一些需要在生成站点文档之前完成的工作</strong></li>
<li><strong>site    生成项目的站点文档</strong></li>
<li><strong>post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</strong></li>
<li><strong>site-deploy     将生成的站点文档部署到特定的服务器上</strong></li>
</ul>
<p><strong>执行mvn命令的时候会执行该生命周期内包含当前phase以及该phase之前所有phase。</strong></p>
<pre><code>lifecycle，phase，goal之间的比较：
一个lifecycle包含多个phase，可以看上文。而一个phase执行的时候会涉及到多个goal执行。所以真正执行操作的是goal。goal的格式一般为 abc:xyz 。
可以类比java：
lifecycle就表示一个java项目中的某个module，一个module中包含多个class，class执行的时候是执行class里面的method，goal就相当于method。
</code></pre>
<h3 id="依赖的scope">依赖的scope</h3>
<table>
<thead>
<tr>
<th>依赖范围（scope）</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>compile</strong></td>
<td>默认路径，相关依赖只在项目的类路径下有效，对于编译，测试，运行三种classpath都有效</td>
<td>log4j</td>
</tr>
<tr>
<td><strong>provided</strong></td>
<td>已提供依赖范围，对于编译，测试的classpath有效，运行时无效，因为容器已经提供</td>
<td>servlet-api</td>
</tr>
<tr>
<td><strong>test</strong></td>
<td>在测试编译阶段和执行阶段有效</td>
<td>junit</td>
</tr>
<tr>
<td><strong>runtime</strong></td>
<td>在编译阶段不是必须的，在执行阶段使用</td>
<td>jdbc</td>
</tr>
<tr>
<td><strong>system</strong></td>
<td>需要提供一个系统路径，见 ** Maven引入外部路径** 部分</td>
<td></td>
</tr>
<tr>
<td><strong>import</strong></td>
<td>该范围只在依赖是一个 pom 里定义的依赖时使用。同时，当前项目的POM 文件的 部分定义的依赖关系可以取代某特定的 POM。 <strong>可实现maven的多继承</strong> ，见type标签中介绍</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="maven仓库">Maven仓库</h3>
<p>Maven中的仓库分为本地仓库，一般是在本机中；中央仓库，maven项目组所维护的一个大型公共仓库；远程仓库，一般是公司自己局域网内部的自建仓库，包含一些公司自己开发的组件。</p>
<pre><code>pom文件中的依赖是先从本地仓库查找，没找到会去pom文件中配置的远程仓库去查找，最后去从中央仓库中查找，最后没找到会提示错误信息，退出。
</code></pre>
<p><strong>本地仓库</strong>：maven的默认仓库是在本机中的${user.home}/.m2/respository/目录下，其中user.dir表示用户目录。当然我们也可以修改默认仓库的路径。只需要修改maven安装目录下的conf目录中的settings.conf。<br>
<img src="https://gushi1912.github.io/post-images/1614426341613.png" alt="" loading="lazy"><br>
**中央仓库：**默认的中央仓库是设置在国外的服务器，速度很慢，我们一般用国内的镜像地址来替代默认的中央仓库。一般选用的是阿里云的镜像仓库地址，当然有多种选择。<br>
<img src="https://gushi1912.github.io/post-images/1614426358216.png" alt="" loading="lazy"><br>
<strong>远程仓库</strong>：如果一些依赖中央仓库没有，只存在于远程仓库，这时我们就需要在pom文件中配置远程仓库地址。</p>
<pre><code class="language-xml">&lt;!-- 在respositories标签下可以声明一个或者多个respository元素--&gt;
&lt;repositories&gt; 
  &lt;repository&gt;
    &lt;!--仓库声明的唯一id，需要注意的是Maven中央仓库的id为central，如果其他仓
    库的id设置为central就会覆盖中央仓库 --&gt;
    &lt;id&gt;&lt;/id&gt;
    &lt;!-- 仓库的名称--&gt;
    &lt;name&gt;&lt;/name&gt;
    &lt;!--仓库的地址 --&gt;
    &lt;url&gt;&lt;/url&gt;
    &lt;!-- 对于仓库中发行版的依赖的下载权限以及相关配置--&gt;
    &lt;releases&gt;
      &lt;!-- 是否允许下载发行版--&gt;
      &lt;enabled&gt;true/false&lt;/enabled&gt;
			&lt;!--从远程仓库检查更新的频率 可选:never,always,daily,interval:X --整数，单位：分钟--&gt;
      &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt;
    &lt;/releases&gt;
    &lt;!-- 对于--&gt;
    &lt;snapshots&gt;
      &lt;enabled&gt;true/false&lt;/enabled&gt;
      &lt;!-- 元素checksumPolicy用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven: 遇到校验和错误就让构建失败；ignore:使Maven完全忽略校验和错误。--&gt;
      &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt;
    &lt;/snapshots&gt;
&lt;!-- 采用默认布局，即Maven2或者Maven3的仓库布局格式，而不是Maven1的布局，现在一般不会用到Maven1的布局--&gt;
    &lt;layout&gt;default&lt;/layout&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p><strong>远程仓库的认证</strong> ：远程仓库可以在pom.xml中直接配置，但是有的远程仓库可能需要账户密码认证，这就需要我们在settings.xml中配置认证信息。</p>
<pre><code class="language-xml">&lt;!-- 配置远程仓库认证信息--&gt;
&lt;servers&gt;
  &lt;server&gt;
    &lt;!--该id信息必须和pom文件中配置的远程仓库的id匹配 --&gt;
    &lt;id&gt;&lt;/id&gt;
    &lt;username&gt;&lt;/username&gt;
    &lt;password&gt;&lt;/password&gt;
  &lt;/server&gt;
&lt;/servers&gt;
</code></pre>
<p><strong>部署构件至远程仓库</strong> ：将打包后的代码部署到远程仓库需要手动配置远程仓库信息。添加以下配置到pom文件中。</p>
<pre><code class="language-XML">&lt;project&gt;
  &lt;distributionManagement&gt;
    &lt;repository&gt;
    	&lt;!--此处的id要和settings.xml文件里配置的id相对应 --&gt;
    	&lt;id&gt;releases&lt;/id&gt;
    	&lt;!--仓库名称 --&gt;
    	&lt;name&gt;Releases&lt;/name&gt;
    	&lt;url&gt;私服仓库地址&lt;/url&gt;
   &lt;/repository&gt;
   &lt;snapshotRespository&gt;
    	&lt;id&gt;releases&lt;/id&gt;
    	&lt;name&gt;Releases&lt;/name&gt;
    	&lt;url&gt;私服仓库地址&lt;/url&gt;
   &lt;/snapshotRespository&gt;
  &lt;/distributionManagement&gt;
&lt;/project&gt;
</code></pre>
<h3 id="maven插件">Maven插件</h3>
<p>Maven生命周期中的每一个阶段的具体实现都是依靠Maven插件实现的。可以使用以下命令格式执行具体goal。</p>
<blockquote>
<p>mvn [plugin-name]:[goal-name]</p>
</blockquote>
<p>例如使用maven-compiler-plugin执行compiler-goal</p>
<blockquote>
<p>mvn compiler:compile</p>
</blockquote>
<p>maven提供了下面两种插件类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Build plugins</td>
<td>在构建时执行，并在pom.xml文件中配置</td>
</tr>
<tr>
<td>reporting plugins</td>
<td>在网站生成过程中执行，并在pom.xml文件中配置</td>
</tr>
</tbody>
</table>
<p>maven插件的编写-步骤简化版：</p>
<blockquote>
<p>关于命名：现有的公共插件使用maven-xxxx-plugin的命名方式，自己编写的插件使用xxxx-maven-plugin的命名方式，xxxx表示插件名称。</p>
</blockquote>
<p>在IDEA中新建一个maven项目，在该界面选中<br>
<img src="https://gushi1912.github.io/post-images/1614426374152.png" alt="" loading="lazy"><br>
剩下的就和新建一个maven项目类似，建好之后会生成两个文件，一个是pom.xml，另一个是名叫MyMojo的文件。我们可以在MyMojo文件中看到一些tag。</p>
<blockquote>
<p>@goal 指定的是插件的名称，就是mvn [plugin-name]:[goal-name]中的goal-name<br>
@phase 将插件绑定在某个生命周期中的具体的某个阶段，比如process-resources<br>
@parameter 插件中所用到的参数</p>
</blockquote>
<p>编写一个简单的maven插件如下：<br>
<img src="https://gushi1912.github.io/post-images/1614426387005.png" alt="" loading="lazy"></p>
<blockquote>
<p>@Mojo注解的功能类似于上面介绍的@goal，其中的name属性就是指定插件的名称。<br>
@Parameter 注解就是设置参数，name是指定插件配置中的参数名称，defaultValue属性表示默认值</p>
</blockquote>
<p>maven插件编写参考;<a href="https://juejin.cn/post/6844904110244757517">https://juejin.cn/post/6844904110244757517</a></p>
<p>一个简单的生成测试用例报告的maven插件使用，使用<strong>mvn surefile-report:report</strong>：</p>
<pre><code class="language-xml">&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
				&lt;version&gt;2.22.2&lt;/version&gt;
				&lt;configuration&gt;
          &lt;!-- 执行所有目录中符合下列匹配规则的类--&gt;
					&lt;includes&gt;
						&lt;include&gt;**/*Tests.java&lt;/include&gt;
					&lt;/includes&gt;
          &lt;!-- 不执行符合下列匹配规则的类--&gt;
          &lt;excludes&gt;
						&lt;exclude&gt;**/Test*.java&lt;/exclude&gt;
					&lt;/excludes&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
</code></pre>
<p>总结：</p>
<ul>
<li>插件是在 pom.xml 中使用 plugins 元素定义的。</li>
<li>每个插件可以有多个目标。</li>
<li>你可以定义阶段，插件会使用它的 phase 元素开始处理。我们已经使用了 <strong>clean</strong> 阶段。</li>
<li>你可以通过绑定到插件的目标的方式来配置要执行的任务。我们已经绑定了 <strong>echo</strong> 任务到 maven-antrun-plugin 的 <strong>run</strong> 目标。</li>
<li>就是这样，Maven 将处理剩下的事情。它将下载本地仓库中获取不到的插件，并开始处理。</li>
</ul>
<h3 id="引入外部依赖">引入外部依赖</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- 在这里添加你的依赖 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ldapjdk&lt;/groupId&gt;  &lt;!-- 库名称，也可以自定义 --&gt;
        &lt;artifactId&gt;ldapjdk&lt;/artifactId&gt;    &lt;!--库名称，也可以自定义--&gt;
        &lt;version&gt;1.0&lt;/version&gt; &lt;!--版本号--&gt;
        &lt;scope&gt;system&lt;/scope&gt; &lt;!--作用域--&gt;
        &lt;systemPath&gt;${basedir}\src\lib\ldapjdk.jar&lt;/systemPath&gt; &lt;!--项目根目录下的lib文件夹下,路径可以修改，比如去掉src放在项目根目录--&gt;
    &lt;/dependency&gt; 
&lt;/dependencies&gt;
</code></pre>
<h3 id="snapshotrelease">Snapshot&amp;Release</h3>
<pre><code class="language-xml">1. Snapshot 版本代表不稳定、尚处于开发中的版本。

2. Release 版本则代表稳定的版本。

3. 什么情况下该用 SNAPSHOT?
		协同开发时，如果 A 依赖构件 B，由于 B 会更新，B 应该使用 SNAPSHOT 来标识自己。这种做法的必要性可以反证			如下：
		a.  如果 B 不用 SNAPSHOT，而是每次更新后都使用一个稳定的版本，那版本号就会升得太快，每天一升甚至每个小时一升，这就是对版本号的滥用。
		b. 如果 B 不用 SNAPSHOT, 但一直使用一个单一的 Release 版本号，那当 B 更新后，A 可能并不会接受到更新。因为 A 所使用的 repository 一般不会频繁更新         release 版本的缓存（即本地 repository)，所以B以不换版本号的方式更新后，A在拿B时发现本地已有这个版本，就不会去远程Repository下载最新的 B

4. 不用 Release 版本，在所有地方都用 SNAPSHOT 版本行不行？     
		不行。正式环境中不得使用 snapshot 版本的库。 比如说，今天你依赖某个 snapshot 版本的第三方库成功构建了自己的应用，明天再构建时可能就会失败，因为今晚第三方可能已经更新了它的 snapshot 库。你再次构建时，Maven 会去远程 repository 下载 snapshot 的最新版本，你构建时用的库就是新的 jar 文件了，这时正确性就很难保证了。
</code></pre>
<h3 id="依赖管理">依赖管理</h3>
<p>特性：</p>
<ul>
<li><strong>依赖传递特性</strong>：A依赖于B，B依赖于C，A就会传递依赖于C。</li>
<li><strong>依赖冲突</strong>：
<ul>
<li>就近原则：A→B→C（1.1）    A→D→E→C（1.2）</li>
</ul>
</li>
</ul>
<p>以上情况，A的传递依赖中出现两个不同版本的C依赖，此时依赖就近原则，优先使用C（1.1）版本。</p>
<ul>
<li>第一声明者优先：A→C→D  A→E→D</li>
</ul>
<p>以上A传递依赖于D的路径是一样的，就按在pom文件中定义的顺序优先使用先定义的。</p>
<p>关于传递依赖：<strong>对于scope范围是test和provoided的依赖无法传递</strong>。</p>
<blockquote>
<p>任何可以传递的依赖都可以使用exclusions来排除，比如A依赖B，B依赖C，A就可以将C标记为排除的。<br>
任何可以传递的依赖都可以使用optional来标记为可选的，比如A依赖B，B依赖C，B可以标记C为可选的，这样A就可以不用依赖C。</p>
</blockquote>
<h3 id="dependencymanagement">DependencyManagement</h3>
<p><dependencyManagement>的用法<br>
<strong>一般在项目的顶层pom文件中使用此元素</strong> <strong>,使用properties来统一管理版本</strong></p>
<pre><code class="language-xml">在父模块中
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.7.36&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

在子模块中
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><strong>说明</strong> ：<br>
使用dependencyManagement标签可以统一管理项目的版本号，确保应用的各个项目的依赖和版本号一致，不用每个模块都设置一个版本号。当需要更新版本号的时候只需要更新父类容器的版本号就可以了。如果一个子项目需要在自己的模块中单独声明自己依赖的版本的时候，可以单独在子模块设置，它会覆盖父类的设置。</p>
<p><strong>dependency与dependencyManagement的区别</strong></p>
<ul>
<li>Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。</li>
<li>dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。<strong>如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项</strong>，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</li>
</ul>
<h3 id="多模块项目设置">多模块项目设置</h3>
<ol>
<li>首先创建一个SpringBoot项目，如果是一个web项目可以添加spring-web依赖。</li>
<li>把创建好的springboot项目中生成的一些目录以及文件删除，比如：src,mvn相关文件，保留pom.xml</li>
<li>在生成的springboot项目目录下新建module，module可以是springboot项目也可以是maven项目，module中pom文件的parent为父pom。</li>
<li><strong>父pom文件中的packaging设置为pom，同时添加包含的子module</strong></li>
</ol>
<pre><code class="language-xml">&lt;modules&gt;
  &lt;module&gt;multi-admin&lt;/module&gt;
  &lt;module&gt;&lt;/module&gt;
&lt;/modules&gt;

&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h4 id="type标签">type标签</h4>
<pre><code class="language-xml">&lt;!-- &lt;type&gt;pom&lt;/type&gt;把spring-boot-dependencies引入为pom 文件 --&gt;
&lt;!-- &lt;scope&gt;import&lt;/scope&gt;解决单继承问题，类似parent标签，把spring-boot-dependencies引入到dependencyManagement --&gt;
&lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<p>type为pom表示引入该类型的pom文件，并且不会实际导入依赖，只是起到一个版本管理的作用，子项目导入依赖的时候不需要添加版本信息。<br>
scope设置为import可以继承另一个pom文件，这样就可以实现多继承。</p>
]]></content>
    </entry>
</feed>